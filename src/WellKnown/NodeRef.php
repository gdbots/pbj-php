<?php
declare(strict_types=1);

namespace Gdbots\Pbj\WellKnown;

use Gdbots\Pbj\Assertion;
use Gdbots\Pbj\Message;
use Gdbots\Pbj\SchemaQName;

/**
 * A NodeRef is a qualified identifier to a node/vertex.  It is less verbose than a MessageRef
 * as it is implied that node labels must be unique within a given vendor namespace and
 * therefore can be represented in a more compact manner.
 *
 * NodeRef Format:
 *  vendor:label:id
 *
 * The "vendor:label" portion is a SchemaQName.  @see SchemaQName
 *
 * @link http://s3.thinkaurelius.com/docs/titan/1.0.0/schema.html section: 5.4. Defining Vertex Labels
 * @link https://neo4j.com/docs/developer-manual/current/introduction/#graphdb-neo4j-labels
 *
 * Examples:
 *  acme:article:41e4532f-2f58-4b9d-afc8-e9c2cbcb4aba
 *  twitter:tweet:789234931599835136
 *  youtube:video:EG0wQRsXLi4
 *
 */
final class NodeRef implements Identifier
{
    /**
     * Regular expression pattern for matching a valid NodeRef id string.
     * @constant string
     */
    const VALID_ID_PATTERN = '/^[\w\/\.:-]+$/';

    private SchemaQName $qname;
    private string $id;

    /**
     * When serialized we store the qname as a string so we can
     * restore the singleton instance upon wakeup.
     */
    private ?string $qs = null;

    public function __construct(SchemaQName $qname, string $id)
    {
        $this->qname = $qname;
        $this->id = trim($id);
        Assertion::regex($this->id, self::VALID_ID_PATTERN, null, 'NodeRef.id');
    }

    public static function fromString(string $string): static
    {
        $parts = explode(':', $string, 3);
        Assertion::count($parts, 3, 'NodeRef format must be "vendor:label:id');
        $id = array_pop($parts);
        $qname = SchemaQName::fromString(implode(':', $parts));
        return new self($qname, $id);
    }

    public static function fromNode(Message $node): static
    {
        if ($node->has('_id')) {
            return new self($node::schema()->getQName(), (string)$node->fget('_id'));
        }

        return self::fromMessageRef($node->generateMessageRef());
    }

    public static function fromMessageRef(MessageRef $messageRef): self
    {
        return new self(SchemaQName::fromCurie($messageRef->getCurie()), $messageRef->getId());
    }

    public function getQName(): SchemaQName
    {
        return $this->qname;
    }

    public function getVendor(): string
    {
        return $this->qname->getVendor();
    }

    public function getLabel(): string
    {
        return $this->qname->getMessage();
    }

    public function getId(): string
    {
        return $this->id;
    }

    public function toString(): string
    {
        return $this->qname->toString() . ':' . $this->id;
    }

    public function __toString()
    {
        return $this->toString();
    }

    public function jsonSerialize(): string
    {
        return $this->toString();
    }

    public function equals(Identifier $other): bool
    {
        return $this == $other;
    }

    /**
     * Creates a NodeRef from a file path, assuming it was generated by the "toFilePath" method.
     *
     * @param string $string
     *
     * @return static
     */
    public static function fromFilePath(string $string): self
    {
        $parts = explode('/', $string, 5);
        unset($parts[2]);
        unset($parts[3]);

        return self::fromString(
            str_replace(['__FS__', '__CLN__'], ['/', ':'], implode(':', $parts))
        );
    }

    /**
     * Returns a string that can be used for a file path.  Special characters
     * in the id, colon and forward slash, are replaced with "__CLN__" and "__FS__"
     * respectively.  The path is also hashed so for large repositories all files
     * don't end up in the same directory.
     */
    public function toFilePath(): string
    {
        $hash = md5($this->id);
        return trim(sprintf(
            '%s/%s/%s/%s/%s',
            $this->qname->getVendor(),
            $this->qname->getMessage(),
            substr($hash, 0, 2),
            substr($hash, 2, 2),
            str_replace(['/', ':'], ['__FS__', '__CLN__'], $this->id)
        ), '/');
    }

    public function __sleep()
    {
        $this->qs = $this->qname->toString();
        return ['qs', 'id'];
    }

    public function __wakeup()
    {
        $this->qname = SchemaQName::fromString($this->qs);
        $this->qs = null;
    }
}
